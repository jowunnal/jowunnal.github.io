---
title: "[네트워크] OSI 7 Architecture Layer"
categories:
- ComputerScience
tags:
- Study
---

강의시간에 배운 OSI 7 Architecture layer에 대해 정리해보고자 한다.

# OSI 7 Architecture Layer 
OSI 7계층은 국제표준기구 ISO(International Standards Organization)에서 정의하였는데, 서로 다른 다양한 Device 들이 서로 통신을 가능하게 할 수 있도록 표준화한 네트워크 표준 모델 이다.

총7계층으로 나누었는데 다음과 같다.

1. 1계층(물리 계층) : Data <-> Signal
2. 2계층(데이터링크 계층) : 에러제어, 흐름제어, 접근제어
3. 3계층(네트워크 계층) : 라우팅, IP
4. 4계층(전송 계층) : 종단간전송, TCP/UDP
5. 5계층(세션 계층) : Session관리, 전이중/반이중
6. 6계층(표현 계층) : 백업,보안
7. 7계층(응용 계층) : 응용프로그램

OSI 7계층은 유럽에서 주도하여 만들어졌지만 현재는 미국에서 주도하여 만들어진 TCP/IP 5계층을 사용하고 있다. 

하나하나 뜯어서 살펴보자

---
# 물리계층
통신은 DTE 라는 장치에서 만들어진 Data 를 DCE를 통해서 Signal 로 바꾸어 전달하면, 수신측의 DCE에서 Signal 을 Data로 바꾸어 DTE에서 받아 처리하는 과정을 수행한다.

물리계층은 이러한 물리적 링크를 확립하고, 통신과정에 이 링크를 유지하고 끝나면 해제하는 과정으로써 컴퓨터와 모뎀을 연결하는 핀의 규격이라던지, 모뎀과 거리확장의 장비들과 그들간의 케이블링과 같은 물리적 장비들의 규격을 프로토콜로써 정의한다.

### 즉, 물리적인 것들인 컴퓨터, 모뎀, 리피터, 브릿지, 라우터, 게이트웨이, 케이블 들 모두에 대해 규정한 것이 물리계층이다.

또한, 물리계층에서의 통신단위는 Bit 이다.

---
# 데이터링크 계층
데이터링크 계층의 핵심은 흐름제어, 에러제어, 접근제어 이다.

흐름제어와 에러제어는 IEEE 802.3 에서 정의한 LLC에서 수행하며, 접근제어는 MAC에서 수행한다.

데이터 링크 계층에서는 상위 계층(네트워크 계층)에서 생성된 패킷에 이더넷 헤더와 트레일러를 삽입하여 프레임을 구성하고, 물리계층으로 전달한다.

이더넷 헤더에는 MAC주소가 삽입되고, 트레일러에는 에러제어 정보가 삽입된다.

### 흐름제어
흐름제어란 송신측에서 보낸 데이터가 수신측의 버퍼에 담기고, 버퍼의 데이터를 컴퓨터에서 처리하는데 걸리는 시간 차이로 인해 수신측의 버퍼의 공간을 초과하여 __Overflow__ 가 발생하지 않도록 하기 위한 기법이다.

흐름제어의 기법에는 대표적으로 2가지 종류가 있다.

- Stop And Wait

송신측에서 패킷 하나를 보낸후에 기다린다. 이후 수신측에서 데이터를 잘받았으면 ACK(확인신호)를 보내어주고, 송신측에서 ACK를 받으면 다음 패킷을 보내고, 오류가 있었다면 NAK를 보내어 송신측에서 재전송을 유도한다.

이방식은 패킷하나를 보내고 기다리는데 걸리는 시간이 발생하여 통신효율이 떨어져서 성능이 떨어진다는 단점이 존재한다.

이를 개선한 방식이 Sliding Window 방법이다.

- Sliding Window

Sliding Window는 수신측에서 패킷을 받으면 ACK에 남은 버퍼 공간크기를 TCP헤더에 담아 보내면, 송신측에서 남은 공간만큼 가변적으로 패킷을 전달하는 형태로 확인신호가 오기 전까지 기다려야 했던 Stop And Wait의 단점을 보완한 방법이다.

### 에러제어
에러제어는 에러 검출(Error Detection)과 에러 정정(Error Correction) 으로 두가지로 나뉜다.

#### Error Detection
에러 검출은 대표적으로 패리티비트, LRC(블록합 검사), CRC, CheckSum 이 있다. 하나씩 살펴보자.

- 패리티비트 : 가장 기초적인 방법으로 한블록의 끝에 한비트를 추가한뒤 짝수 패리티 혹은 홀수 패리티 방식에 따라 에러를 검출하는 방법이다.

짝수 패리티였다면 블록의 비트들중 1이 짝수개였으면 에러가 없는것이고, 홀수개 였다면 에러가 있었다는 의미로 에러가 검출되면 재전송을 요구한다. 또한 홀수 패리티 방식은 그와 반대다.

패리티비트 방식의 단점은 에러가 짝수개가 발생했을 때 검출이 불가능 하다는 점이다.

2개비트에서 에러가 났다고 가정해보자. 홀수 패리티든 짝수 패리티든 에러가 났다고 확인이 안된다.

- LRC (블록합 검사) : 2차원 패리티 검사라고도 불리며 전달된 블록들을 일정크기로 묶어서 2차원 배열 형태로 만들고 행/열 의 끝에 __한 블록씩을 추가하여__ 에러를 검출하는 방법이다.

기존의 패리티비트 방식을 일정량을 묶어서 2차원 배열형태로 만드는 것인데, 블록합 검사의 경우 같은 열의 짝수개의 에러를 검출할 수 없다는 단점이 존재한다.

- CRC(순환 중복 검사) : 한블록의 Original 데이터에 송수신측에서 동일하게 정의한 다항식으로 __캐리가없는 Modulo-2 연산__ 을 적용하여 발생한 나머지를 CRC필드로 추가하여 송신측에서 데이터 CRC필드를 더하여 보냈을때 수신측에서 받아 같은 다항식으로 캐리가없는 Modulo-2 연산을 적용했을 때 나머지가 0이면 에러가 없고, 0이아니면 에러가 존재하는 방법으로 검출한다.

예를들어,  01101011 이라는 데이터를 CRC-8의 에러검출 알고리즘으로 전송한다고 가정해보자

다항식은 이미 정해져있는 x^8 + x^2 + x + 1(CRC-8) 이 되며, 이것으로 XOR 연산하였을 때 나머지가 00010110 이며, 이것이 CRC필드가 된다.

그럼 original 데이터에 CRC필드를 더하여(이어붙여서) 0110101100010110 을 전송하고, 수신측에서 동일한 정해진 다항식으로 XOR 연산한 것이 0이면 에러가없고, 0이아니면 에러가있어서 재전송을 요구하게 된다.

CRC의 경우 유럽의 표준이 CRC-CCITT(16비트) 이며, CRC-32는 IEEE802와 Ethernet에서 사용하여 두개의 방식이 가장 많이 사용된다.

- CheckSum : 송신측에서 전송할 데이터(Original Data)들을 모두 더하여 1의 보수화한 뒤에 Original Data에 이어붙여서 전송한후 수신측에서 모든 데이터를 더하여 1의 보수화를 했을때 0이면 에러가없고, 0이아니면 에러가 있음을 통해 검출하는 방법

2, 4바이트 CheckSum을 가장 많이 사용하며 IP, TCP/UDP에서 2Byte CheckSum을 이용하고 있다.

#### Error Correction

에러 정정은 대표적으로 ARQ와 FEQ로 나뉜다.

ARQ란 에러가 Detection 되면 재전송을 요구하는 방법이고, FEQ는 에러를 수신측에서 직접 Correction 하는 방법이다.

ARQ를 먼저 보자면, Stop And Wait ARQ, Go back -N ARQ, Selective Repeat ARQ로 대표적으로 3가지가 있다.

- Stop And Wait ARQ : 흐름제어에서 설명한 Stop And Wait 방식에서 재전송을 요구하는 방법이다.

송신측에서 데이터를 전송하면, 수신측에서 에러가 없으면 ACK를 보내고 송신측에서 ACK를 받으면 다음데이터를 전송한다.

만약 에러가 발생했다면, 수신측에서 NAK를 보내고 송신측에서 동일 데이터를 재전송 한다.

이는 위에서 서술한 바와 같이 하나를 보내고 기다려야 해서 통신효율이 떨어진다는 단점이 있다.

- Go back -N ARQ : 송신측에서 데이터를 기다리지 않고 연속적으로 보내어 에러가 발생했을 때 발생한 에러의 데이터부터 다시 순서대로 보내는 방법이다.

예를들어 1,2,3,4,5,6,7,8,9,10 순으로 데이터를 보낸다고 가정해 보자.

1, 2, 3 까지는 수신측에서 에러가 없었는데 4에서 에러가 발생했다.

하지만 송신측은 연속적으로 데이터를 보내기 때문에 5,6,7 까지 이미 전달된 상황이다.

수신측에서 NAK4 를 보내면 송신측에서 4부터 다시 4,5,6,7 순으로 재전송 하게 된다.

- Selective Repeat ARQ : Go back -N과 달리 에러가 발생한 데이터만 다시 선택적으로 보내는 방법이다.

위의 동일한 상황에서 NAK4를 송신측으로 보내면 송신측은 4를 재전송하고, 나머지 데이터인 8,9,10 을 보내게 된다.

현재는 Selective Repeat 보다 Go back -N 방식을 많이 사용하고 있다.

Seletive Repeat의 경우 중간의 데이터를 선택적으로 전송하면, 수신측에서는 1,2,3 과  5,6,7 사이에 4를 연결해야 하는 Memory Management가 발생한다.

이는 추가적인 메모리내의 연산을 발생시켜서 성능적으로 더 안좋다고 한다.

따라서 에러 발생지점부터 순차적으로 다시 보내어 Memory Management가 발생하지 않는 Go back -N 방법을 많이 사용한다고 한다.

다음으로 FEQ를 보자.

FEQ는 ARQ와 달리 에러를 수신측에서 직접 정정해야 하기 때문에 추가적인 에러 확인 용도의 비트가 추가된 데이터를 받아야 한다.

즉, 전달되는 정보의 크기가 커서 통신효율이 떨어진다는 단점이 있다. 따라서 잘 사용되지 않는 방법이다.

하지만 위성과 같은 거리가 아주 먼 통신을 할 때는 사용된다. 

예를들어 위성의경우 수백km~ 수천km 만큼 멀리 떨어진 곳에 통신해야 하는데 ARQ같은 재전송 알고리즘을 사용하면 재전송 받기까지 시간이 오래걸려서 오히려 통신효율이 떨어진다.

따라서 이럴때는 한번 보낼때 에러정정코드를 삽입하여 보내어 통신효율을 증대한다.

FEQ에는 대표적으로 해밍코드(단일비트 오류정정), 상승코드(다중비트 요류정정) 가 있다.

해밍코드와 상승코드는 너무 길어지므로 생략하겠다.

### 접근제어

접근제어는 특정순간에 어느 시스템이 회선을 점유할 것인지를 결정하는 기능으로 [LAN](https://jowunnal.github.io/computerscience/LAN/ "link") 에서 설명했듯이 MAC 과 관련있다.

가입자망은 90퍼센트 이상이 LAN을 사용하고, LAN의 토폴로지는 Sharing 회선(버스, 링, 스타, 트리)으로 구성되기 때문에 회선을 공유할 때 충돌이 발생하지 않도록 하기 위해 접근제어가 필수적이다.

 [LAN](https://jowunnal.github.io/computerscience/LAN/ "link") 의 CSMA/CD 소개에서 자세히 설명해 두었으니 참조하면 될거같다.
 
 ---
