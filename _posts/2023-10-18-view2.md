---
title: "[Android] View #2 Compose Layout"
categories:
- Android
tags:
- Study
---

[Android View #1](https://jowunnal.github.io/android/View/ "link")에 이어서 Compose Layout은 Activity에서 어떻게 연결되고, 어떻게 생성되고, 사라지기 까지의 lifecycle에 대해서 공부한내용을 정리해보고자 한다.

# What's Difference
---

Jetpack Compose는 선언형 UI 패러다임으로 kotlin 코드로 작성하여 UI를 만들수 있는 프레임워크 이다.

기존의 명령형 UI 패러다임으로 작성했던 Android View는 여러가지 문제점이 있었다.

### Overdraw
[Android View #1](https://jowunnal.github.io/android/View/ "link") 에서 보았듯이, 기존의 방법은 layoutResource를 inflate 과정을 통해 메모리상에 tree 구조로 뷰객체를 만들어 둔다.

ViewGroup이 많아질수록 tree의 구조는 깊어지고, 이것이 rendering 과정에서 __덮어쓰는__ 형태로 그려지다보니 성능상 문제가 심각했다.

그것의 대안으로 만들어진 것이 __constraintLayout__ 이고 우리는 이 viewgroup 을 통해 view tree의 깊이를 평탄화 하여 UI element들을 생성할수 있었다.

이와 달리 Compose Layout은 UI tree를 [gap Buffer](https://jisungbin.medium.com/gap-buffer-%EA%B0%84%EB%8B%A8%ED%9E%88-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-e1ed40649af9 "link")자료구조로 메모리에 1차원배열 구조로 저장하기 때문에 이러한 문제들을 해결하였다.

### Measure Pass
View의 lifecycle과정에서 보았듯이, onMeasure()는 __한번이상__ 호출될수 있다는 것을 알았다.

하지만 이것이 자식 view를 측정한후 다시 부모view를 측정하고 그에따라 또다시 자식View를 측정해야 하는 알고리즘으로 작성되기 때문에 성능상 좋지않았고 그에따라 transition animation을 만들기가 까다로웠다.

Jetpack Compose는 layout composable을 생성할 때 __single pass__ 로 그려지기 때문에 한번의 측정만으로 UI tree를 모두 측정한다. 또한 2번이상 측정할 경우 예외를 발생시킨다.

또한, onMeasure 이후 onLayout이 호출되는 순서가 엄격하지 않아 measure 되지 않은 view가 layout되는 미묘한 버그들도 발생할 수 있었지만 Compose Layout은 kotlin-dsl scope로 __측정된 것만 배치__ 한다는 개선점도 있다. 

### 명령형 과 선언형
선언형이라는 것은 명령형과 달리 "어떻게" 가 아니라  "무엇을" 에 집중하는 프로그래밍 방법이다.

또한 선언형 패러다임의 일종인 함수형 패러다임에 따라 기본적으로 순수함수의 원칙에 따라 함수의 입력값이 달라지면, 함수의 출력값이 달라지는 것만 허용하며, 그이외의 side effect를 허용하지 않는 함수를 말한다.

[Jetpack Compose Deep Dive](https://youtu.be/zMKMwh9gZuI "link")를 보면, 도입부에서 state를 통해 UI를 만든다고 얘기한다.

Jetpack Compose에서는 함수의 입력 매개변수 뿐만아니라 내부에 mutableStateOf api로 생성된 state객체의 변화를 감지하고, state로 UI를 생성 뿐만아니라 재구성(recomposition)을 발생시킴으로써 UI를 update한다.

이러한점들 뿐만아니라 kotlin 코드로 UI를 생성할수 있다는 장점과 높은 생산성이 있는 Compose를 최근에 Google에서 밀고있다.

도입은 이정도로 마무리하고, 마찬가지로 compose layout의 시작점인 ComponentActivity.setContent() 메소드의 구현체부터 살펴보겠다.

# ComponentActivity.setContent()
---

```java
public fun ComponentActivity.setContent(
    parent: CompositionContext? = null,
    content: @Composable () -> Unit
) {
    val existingComposeView = window.decorView
        .findViewById<ViewGroup>(android.R.id.content)
        .getChildAt(0) as? ComposeView

    if (existingComposeView != null) with(existingComposeView) {
        setParentCompositionContext(parent)
        setContent(content)
    } else ComposeView(this).apply {
        setParentCompositionContext(parent)
        setContent(content)
        setOwners()
        setContentView(this, DefaultActivityContentLayoutParams)
    }
}
```

먼저 가장눈에 보이는 부분은 mContentParent에 있는 view tree의 최상위 view를 가져와서 ComposeView 타입으로 캐스팅한다.

이것이 null이면 ComposeView 인스턴스를 만들어 추가적으로 setOwners() 와 앞서 다룬 ComponentActivity.setContentView()를 수행한다.

만약, null이 아니면 이미 존재하기 때문에 현재의 content를 교체하고 compositionContext를 설정한다.

compositionContext? 이것이 의미하는게 뭘까
